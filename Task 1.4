#!/usr/bin/env python3
import ev3dev.ev3 as ev3
import time
import sys
import csv

try:
    motor_L = ev3.LargeMotor('outB')
    motor_R = ev3.LargeMotor('outC')
    light_sensor = ev3.ColorSensor('in1') 
    dist_sensor = ev3.UltrasonicSensor('in3')
except Exception as e:
    print("FATAL: Hardware Port Mismatch!")
    print(str(e))
    print("Please check: Left Motor (B), Right Motor (C), Color (1), Ultrasonic (3)")
    time.sleep(10)
    sys.exit()

light_sensor.mode = 'COL-REFLECT'
dist_sensor.mode = 'US-DIST-CM'

CAL_BLACK = 8.0
CAL_WHITE = 71.0
CAL_TARGET = 32.0 

GAIN_PROP = 1.0
GAIN_DERIV = 4.5

FWD_SPEED = 180
SEARCH_TURN_SPEED = 250
OBSTACLE_THRESH_CM = 4
MAX_MOTOR_SPEED_SP = 1000

LOST_TIMER_DURATION = 0.3
SWEEP_DURATION_MS = 800
TURN_180_DURATION_MS = 1100

EDGE_TOLERANCE_BAND = (CAL_WHITE - CAL_BLACK) * 0.25
THRESH_LOST = CAL_TARGET + EDGE_TOLERANCE_BAND
THRESH_FOUND = CAL_TARGET - EDGE_TOLERANCE_BAND

MODE_FOLLOW = "FOLLOW"
MODE_SEARCH = "SEARCH"
MODE_OBSTACLE = "OBSTACLE"
MODE_INTERSECTION = "CROSS"

current_mode = MODE_FOLLOW
prev_error = 0.0
last_seen_direction = 0
time_line_lost_at = None
is_mission_complete = False
has_seen_obstacle = False

telemetry_log = []
session_start_time = time.time()

def export_log_to_csv(log_data, filename="robot_telemetry.csv"):
    print("\nExporting telemetry to {}...".format(filename))
    try:
        with open(filename, 'w', newline='') as f:
            writer = csv.writer(f)
            writer.writerow([
                "timestamp", "reflection", "motor_L_speed", 
                "motor_R_speed", "steering_adj", "robot_mode"
            ])
            writer.writerows(log_data)
        print("Telemetry saved successfully.")
    except Exception as e:
        print("Error saving CSV: {}".format(e))

def find_line_sweep(sweep_direction):
    global current_mode
    current_mode = MODE_SEARCH
    
    dir_name = "LEFT" if sweep_direction < 0 else "RIGHT"
    print("Sweeping {} to find line...".format(dir_name))
    
    motor_L.run_timed(
        time_sp=SWEEP_DURATION_MS,
        speed_sp=SEARCH_TURN_SPEED * sweep_direction,
        stop_action="brake"
    )
    motor_R.run_timed(
        time_sp=SWEEP_DURATION_MS,
        speed_sp=-SEARCH_TURN_SPEED * sweep_direction,
        stop_action="brake"
    )
    
    while motor_L.is_running:
        reflection = light_sensor.reflected_light_intensity
        if reflection < THRESH_FOUND:
            motor_L.stop(stop_action="brake")
            motor_R.stop(stop_action="brake")
            print("Line FOUND on {}!".format(dir_name))
            return True
        time.sleep(0.01)
        
    print("Line NOT found on {}.".format(dir_name))
    
    motor_L.run_timed(
        time_sp=SWEEP_DURATION_MS,
        speed_sp=-SEARCH_TURN_SPEED * sweep_direction,
        stop_action="brake"
    )
    motor_R.run_timed(
        time_sp=SWEEP_DURATION_MS,
        speed_sp=SEARCH_TURN_SPEED * sweep_direction,
        stop_action="brake"
    )
    motor_L.wait_while('running')
    motor_R.wait_while('running')
    
    return False

def perform_180_turn():
    global prev_error
    print("Dead end. Executing 180-degree turn...")
    
    motor_L.run_timed(
        time_sp=TURN_180_DURATION_MS, 
        speed_sp=350, 
        stop_action="brake"
    )
    motor_R.run_timed(
        time_sp=TURN_180_DURATION_MS, 
        speed_sp=-350, 
        stop_action="brake"
    )
    motor_L.wait_while('running')
    motor_R.wait_while('running')
    prev_error = 0.0

def recover_from_line_loss():
    global prev_error, current_mode, last_seen_direction
    global is_mission_complete, has_seen_obstacle
    
    print("\n--- LINE LOST ---")
    current_mode = MODE_SEARCH
    motor_L.stop(stop_action="brake")
    motor_R.stop(stop_action="brake")
    time.sleep(0.2)
    
    if last_seen_direction != 0:
        if find_line_sweep(last_seen_direction):
            prev_error = 0.0
            current_mode = MODE_FOLLOW
            return
            
    opposite_direction = -last_seen_direction if last_seen_direction != 0 else 1
    if find_line_sweep(opposite_direction):
        last_seen_direction = opposite_direction
        prev_error = 0.0
        current_mode = MODE_FOLLOW
        return
        
    if has_seen_obstacle:
        print("Line not found AND obstacle was seen. Assuming MAZE END.")
        is_mission_complete = True
    else:
        perform_180_turn()
        
        print("Searching for line after 180 turn...")
        if find_line_sweep(1):
            last_seen_direction = 1
        elif find_line_sweep(-1):
            last_seen_direction = -1
        else:
            print("CRITICAL: Still no line after 180 turn. Stopping.")
            is_mission_complete = True
            
    prev_error = 0.0
    current_mode = MODE_FOLLOW

def navigate_intersection():
    global prev_error, current_mode
    
    print("Intersection (cross-line) detected.")
    current_mode = MODE_INTERSECTION
    
    motor_L.run_timed(time_sp=400, speed_sp=FWD_SPEED, stop_action="brake")
    motor_R.run_timed(time_sp=400, speed_sp=FWD_SPEED, stop_action="brake")
    motor_L.wait_while('running')
    motor_R.wait_while('running')
    
    prev_error = 0.0
    current_mode = MODE_FOLLOW

print("\nStarting Main Control Loop...")
print("Press Ctrl+C to stop the program.\n")

try:
    while not is_mission_complete:
        
        distance_cm = dist_sensor.value() / 10.0
        
        if distance_cm < OBSTACLE_THRESH_CM:
            if current_mode != MODE_OBSTACLE:
                print("OBSTACLE detected at {:.1f}cm".format(distance_cm))
                current_mode = MODE_OBSTACLE
                has_seen_obstacle = True
            
            motor_L.stop(stop_action="brake")
            motor_R.stop(stop_action="brake")
            prev_error = 0.0
            time_line_lost_at = None
            
            time.sleep(0.1)
            continue
            
        if current_mode == MODE_OBSTACLE:
            print("Obstacle cleared. Resuming line following.")
            current_mode = MODE_FOLLOW
            
        reflection = light_sensor.reflected_light_intensity
        
        if reflection < (CAL_BLACK + 3):
            navigate_intersection()
            continue
            
        if reflection > THRESH_LOST:
            if time_line_lost_at is None:
                time_line_lost_at = time.time()
            elif (time.time() - time_line_lost_at) > LOST_TIMER_DURATION:
                recover_from_line_loss()
                time_line_lost_at = None
                continue
        else:
            time_line_lost_at = None
            if current_mode == MODE_SEARCH:
                current_mode = MODE_FOLLOW
                
        if current_mode != MODE_FOLLOW:
            time.sleep(0.01)
            continue
            
        p_error = reflection - CAL_TARGET
        
        if abs(p_error) > 5:
            last_seen_direction = 1 if p_error > 0 else -1
            
        d_error = p_error - prev_error
        steering_adj = (GAIN_PROP * p_error) + (GAIN_DERIV * d_error)
        prev_error = p_error
        
        speed_L = FWD_SPEED - steering_adj
        speed_R = FWD_SPEED + steering_adj
        
        speed_L = max(-MAX_MOTOR_SPEED_SP, min(speed_L, MAX_MOTOR_SPEED_SP))
        speed_R = max(-MAX_MOTOR_SPEED_SP, min(speed_R, MAX_MOTOR_SPEED_SP))
        
        motor_L.run_forever(speed_sp=speed_L)
        motor_R.run_forever(speed_sp=speed_R)
        
        timestamp = time.time() - session_start_time
        telemetry_log.append([
            timestamp, 
            reflection, 
            speed_L, 
            speed_R, 
            steering_adj,
            current_mode
        ])
        
        time.sleep(0.01)

except KeyboardInterrupt:
    print("\n\nProgram terminated by user (Ctrl+C).")
finally:
    print("\nShutting down motors and saving data...")
    motor_L.stop(stop_action="brake")
    motor_R.stop(stop_action="brake")
    export_log_to_csv(telemetry_log)
    print("Cleanup complete.")
